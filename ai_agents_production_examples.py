
# üöÄ PRODUCTION-READY AI –ê–ì–ï–ù–¢–´
# –†–µ–∞–ª—å–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã —Å –Ω–∞—Å—Ç–æ—è—â–∏–º–∏ API –∏ —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–∞–º–∏

# =============================================================================
# –†–ê–ó–î–ï–õ 9: –†–ï–ê–õ–¨–ù–´–ï LANGCHAIN –ê–ì–ï–ù–¢–´
# =============================================================================

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:
# pip install langchain langchain-openai langchain-community langchain-experimental
# pip install tavily-python duckduckgo-search wikipedia
# pip install chromadb faiss-cpu sentence-transformers

from typing import List, Dict, Any, Optional, Union
import os
import json
from datetime import datetime, timedelta
import asyncio
import logging

# LangChain imports
"""
from langchain_openai import ChatOpenAI
from langchain_core.tools import Tool
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage
from langchain.agents import create_openai_functions_agent, AgentExecutor
from langchain.memory import ConversationBufferWindowMemory
from langchain_community.tools import DuckDuckGoSearchRun
from langchain_community.tools.wikipedia.tool import WikipediaQueryRun
from langchain_community.utilities.wikipedia import WikipediaAPIWrapper
from langchain_community.vectorstores import Chroma
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.schema import Document
"""

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ProductionReActAgent:
    """
    Production-ready ReAct –∞–≥–µ–Ω—Ç —Å –ø–æ–ª–Ω—ã–º –Ω–∞–±–æ—Ä–æ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤

    –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
    - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å OpenAI API
    - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
    - –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    - –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
    - –ü–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞—è –ø–∞–º—è—Ç—å
    """

    def __init__(self, 
                 openai_api_key: str,
                 model: str = "gpt-4-turbo-preview",
                 temperature: float = 0.7,
                 max_iterations: int = 10):

        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ LLM
        self.llm = None  # ChatOpenAI(api_key=openai_api_key, model=model, temperature=temperature)
        self.max_iterations = max_iterations

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
        self.tools = self._initialize_tools()

        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞–º—è—Ç–∏
        self.memory = None  # ConversationBufferWindowMemory(k=10, return_messages=True)

        # –°–æ–∑–¥–∞–Ω–∏–µ –∞–≥–µ–Ω—Ç–∞
        self.agent_executor = self._create_agent()

        logger.info(f"ProductionReActAgent initialized with {len(self.tools)} tools")

    def _initialize_tools(self) -> List:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞–±–æ—Ä–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤"""
        tools = []

        # 1. –ü–æ–∏—Å–∫ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ
        """
        search_tool = Tool(
            name="web_search",
            description="Search the internet for current information. Use this when you need up-to-date information.",
            func=DuckDuckGoSearchRun().run
        )
        tools.append(search_tool)
        """

        # 2. Wikipedia –ø–æ–∏—Å–∫
        """
        wikipedia = WikipediaQueryRun(api_wrapper=WikipediaAPIWrapper())
        wiki_tool = Tool(
            name="wikipedia",
            description="Search Wikipedia for encyclopedic information on any topic.",
            func=wikipedia.run
        )
        tools.append(wiki_tool)
        """

        # 3. –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä
        def safe_calculator(expression: str) -> str:
            """–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä"""
            try:
                # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
                allowed_chars = set('0123456789+-*/.() ')
                if not all(c in allowed_chars for c in expression):
                    return "Error: Invalid characters in expression"

                result = eval(expression)
                return f"Result: {result}"
            except Exception as e:
                return f"Calculation error: {str(e)}"

        calc_tool = Tool(
            name="calculator",
            description="Perform mathematical calculations. Input should be a valid mathematical expression.",
            func=safe_calculator
        )
        tools.append(calc_tool)

        # 4. –†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏
        def file_operations(operation: str) -> str:
            """–†–∞–±–æ—Ç–∞ —Å —Ñ–∞–π–ª–∞–º–∏"""
            try:
                if operation.startswith("read:"):
                    filename = operation[5:].strip()
                    if os.path.exists(filename):
                        with open(filename, 'r', encoding='utf-8') as f:
                            content = f.read()[:1000]  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä
                        return f"File content (first 1000 chars): {content}"
                    else:
                        return f"File {filename} not found"

                elif operation.startswith("write:"):
                    parts = operation[6:].split("|", 1)
                    if len(parts) == 2:
                        filename, content = parts
                        with open(filename.strip(), 'w', encoding='utf-8') as f:
                            f.write(content.strip())
                        return f"Successfully wrote to {filename}"
                    else:
                        return "Invalid write format. Use: write:filename|content"

                elif operation.startswith("list:"):
                    directory = operation[5:].strip() or "."
                    files = os.listdir(directory)[:20]  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
                    return f"Files in {directory}: {', '.join(files)}"

                else:
                    return "Available operations: read:filename, write:filename|content, list:directory"

            except Exception as e:
                return f"File operation error: {str(e)}"

        file_tool = Tool(
            name="file_operations",
            description="Read, write, or list files. Use format: read:filename, write:filename|content, or list:directory",
            func=file_operations
        )
        tools.append(file_tool)

        # 5. –î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è
        def datetime_tool(query: str) -> str:
            """–†–∞–±–æ—Ç–∞ —Å –¥–∞—Ç–æ–π –∏ –≤—Ä–µ–º–µ–Ω–µ–º"""
            now = datetime.now()

            if "current" in query.lower() or "now" in query.lower():
                return f"Current date and time: {now.strftime('%Y-%m-%d %H:%M:%S')}"
            elif "date" in query.lower():
                return f"Current date: {now.strftime('%Y-%m-%d')}"
            elif "time" in query.lower():
                return f"Current time: {now.strftime('%H:%M:%S')}"
            elif "tomorrow" in query.lower():
                tomorrow = now + timedelta(days=1)
                return f"Tomorrow's date: {tomorrow.strftime('%Y-%m-%d')}"
            elif "yesterday" in query.lower():
                yesterday = now - timedelta(days=1)
                return f"Yesterday's date: {yesterday.strftime('%Y-%m-%d')}"
            else:
                return f"Current date and time: {now.strftime('%Y-%m-%d %H:%M:%S')}"

        time_tool = Tool(
            name="datetime",
            description="Get current date, time, or calculate dates. Ask for 'current time', 'today', 'tomorrow', etc.",
            func=datetime_tool
        )
        tools.append(time_tool)

        return tools

    def _create_agent(self):
        """–°–æ–∑–¥–∞–Ω–∏–µ –∞–≥–µ–Ω—Ç–∞ —Å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏"""
        # –í —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –∞–≥–µ–Ω—Ç–∞
        # return create_openai_functions_agent(self.llm, self.tools, prompt)
        # return AgentExecutor(agent=agent, tools=self.tools, memory=self.memory, verbose=True)

        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
        class MockAgentExecutor:
            def __init__(self, tools):
                self.tools = {tool.name: tool for tool in tools}

            def run(self, input_dict):
                query = input_dict.get("input", "")

                # –ü—Ä–æ—Å—Ç–∞—è –ª–æ–≥–∏–∫–∞ –≤—ã–±–æ—Ä–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
                if "calculate" in query or "math" in query:
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
                    import re
                    numbers = re.findall(r'[0-9+\-*/().\s]+', query)
                    if numbers:
                        return self.tools["calculator"].func(numbers[0].strip())

                elif "time" in query or "date" in query:
                    return self.tools["datetime"].func(query)

                elif "file" in query:
                    return self.tools["file_operations"].func("list:.")

                else:
                    return "I understand your query, but I need to use specific tools to help you better."

        return MockAgentExecutor(self.tools)

    def run(self, query: str) -> str:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞"""
        try:
            logger.info(f"Processing query: {query}")

            result = self.agent_executor.run({"input": query})

            logger.info(f"Query completed successfully")
            return result

        except Exception as e:
            logger.error(f"Error processing query: {str(e)}")
            return f"I encountered an error: {str(e)}"

    async def arun(self, query: str) -> str:
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞"""
        try:
            # –í —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ: result = await self.agent_executor.arun({"input": query})
            result = self.run(query)  # –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –∑–∞–≥–ª—É—à–∫–∞
            return result
        except Exception as e:
            logger.error(f"Error in async processing: {str(e)}")
            return f"Async error: {str(e)}"

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è Production ReAct –∞–≥–µ–Ω—Ç–∞
def demo_production_agent():
    """–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è production –∞–≥–µ–Ω—Ç–∞"""
    print("=== PRODUCTION REACT –ê–ì–ï–ù–¢ ===")

    # –í —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ –Ω—É–∂–µ–Ω API –∫–ª—é—á OpenAI
    # agent = ProductionReActAgent(openai_api_key="your-api-key-here")

    # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
    class MockAgent:
        def __init__(self):
            self.tools = [
                type('Tool', (), {'name': 'calculator', 'func': lambda x: f"Calculated: {x}"})(),
                type('Tool', (), {'name': 'datetime', 'func': lambda x: f"Time info: {datetime.now()}"})()
            ]

        def run(self, query):
            if "calculate" in query or "math" in query:
                return "Result: 42 (using calculator tool)"
            elif "time" in query:
                return f"Current time: {datetime.now().strftime('%H:%M:%S')}"
            return f"Processed query: {query}"

    agent = MockAgent()

    # –¢–µ—Å—Ç–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã
    test_queries = [
        "What's 15 * 8 + 7?",
        "What time is it now?",
        "Tell me about artificial intelligence"
    ]

    for query in test_queries:
        print(f"\nQuery: {query}")
        result = agent.run(query)
        print(f"Result: {result}")

# –ó–∞–ø—É—Å–∫ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
demo_production_agent()

# =============================================================================
# –†–ê–ó–î–ï–õ 10: RAG –°–ò–°–¢–ï–ú–ê –° –ê–ì–ï–ù–¢–ê–ú–ò
# =============================================================================

class ProductionRAGAgent:
    """
    Production RAG —Å–∏—Å—Ç–µ–º–∞ —Å –∞–≥–µ–Ω—Ç–∞–º–∏

    –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:
    - –í–µ–∫—Ç–æ—Ä–Ω–∞—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö (Chroma)
    - Embedding –º–æ–¥–µ–ª—å (HuggingFace)
    - Retrieval –∞–≥–µ–Ω—Ç
    - Generation –∞–≥–µ–Ω—Ç
    - Query routing –∞–≥–µ–Ω—Ç
    """

    def __init__(self, 
                 documents: List[str] = None,
                 embedding_model: str = "all-MiniLM-L6-v2",
                 chunk_size: int = 1000,
                 chunk_overlap: int = 200):

        self.chunk_size = chunk_size
        self.chunk_overlap = chunk_overlap

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        self._setup_embeddings(embedding_model)
        self._setup_vectorstore()

        if documents:
            self.add_documents(documents)

        # –ê–≥–µ–Ω—Ç—ã
        self.query_router = QueryRouterAgent()
        self.retrieval_agent = RetrievalAgent(self.vectorstore)
        self.generation_agent = GenerationAgent()

        logger.info("ProductionRAGAgent initialized")

    def _setup_embeddings(self, model_name: str):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ embeddings"""
        # –í —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ:
        # self.embeddings = HuggingFaceEmbeddings(model_name=model_name)

        # –ó–∞–≥–ª—É—à–∫–∞
        class MockEmbeddings:
            def embed_documents(self, texts):
                return [[0.1] * 384 for _ in texts]

            def embed_query(self, text):
                return [0.1] * 384

        self.embeddings = MockEmbeddings()

    def _setup_vectorstore(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞"""
        # –í —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ:
        # self.vectorstore = Chroma(embedding_function=self.embeddings, persist_directory="./chroma_db")

        # –ó–∞–≥–ª—É—à–∫–∞
        class MockVectorStore:
            def __init__(self):
                self.docs = []

            def add_documents(self, documents):
                self.docs.extend(documents)
                return len(documents)

            def similarity_search(self, query, k=5):
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–µ—Ä–≤—ã–µ k –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
                return self.docs[:k]

        self.vectorstore = MockVectorStore()

    def add_documents(self, documents: List[str]):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤ –≤–µ–∫—Ç–æ—Ä–Ω—É—é –ë–î"""
        # –†–∞–∑–±–∏–≤–∫–∞ –Ω–∞ —á–∞–Ω–∫–∏
        # text_splitter = RecursiveCharacterTextSplitter(
        #     chunk_size=self.chunk_size,
        #     chunk_overlap=self.chunk_overlap
        # )

        # –ü—Ä–æ—Å—Ç–∞—è —Ä–∞–∑–±–∏–≤–∫–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
        chunks = []
        for doc in documents:
            doc_chunks = [doc[i:i+self.chunk_size] for i in range(0, len(doc), self.chunk_size-self.chunk_overlap)]
            chunks.extend(doc_chunks)

        # –°–æ–∑–¥–∞–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
        docs = [{"page_content": chunk, "metadata": {"source": f"doc_{i}"}} for i, chunk in enumerate(chunks)]

        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –≤–µ–∫—Ç–æ—Ä–Ω—É—é –ë–î
        added_count = self.vectorstore.add_documents(docs)
        logger.info(f"Added {added_count} document chunks to vector store")

        return added_count

    def query(self, question: str) -> Dict[str, Any]:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ —á–µ—Ä–µ–∑ RAG –ø–∞–π–ø–ª–∞–π–Ω"""

        # 1. –ú–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞
        query_type = self.query_router.route(question)

        # 2. –ü–æ–∏—Å–∫ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
        relevant_docs = self.retrieval_agent.retrieve(question, k=5)

        # 3. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞
        answer = self.generation_agent.generate(question, relevant_docs)

        return {
            "question": question,
            "query_type": query_type,
            "relevant_documents": len(relevant_docs),
            "answer": answer,
            "sources": [doc.get("metadata", {}).get("source", "unknown") for doc in relevant_docs]
        }

class QueryRouterAgent:
    """–ê–≥–µ–Ω—Ç –¥–ª—è –º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤"""

    def route(self, query: str) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∑–∞–ø—Ä–æ—Å–∞"""
        query_lower = query.lower()

        if any(word in query_lower for word in ["what", "define", "explain", "describe"]):
            return "factual"
        elif any(word in query_lower for word in ["how", "step", "process", "method"]):
            return "procedural"
        elif any(word in query_lower for word in ["why", "reason", "cause", "because"]):
            return "causal"
        elif any(word in query_lower for word in ["compare", "difference", "versus", "vs"]):
            return "comparative"
        else:
            return "general"

class RetrievalAgent:
    """–ê–≥–µ–Ω—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"""

    def __init__(self, vectorstore):
        self.vectorstore = vectorstore

    def retrieve(self, query: str, k: int = 5) -> List[Dict]:
        """–ü–æ–∏—Å–∫ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"""
        docs = self.vectorstore.similarity_search(query, k=k)
        return docs

class GenerationAgent:
    """–ê–≥–µ–Ω—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤"""

    def generate(self, question: str, context_docs: List[Dict]) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞"""

        # –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        context = "\n\n".join([doc.get("page_content", "") for doc in context_docs])

        # –í —Ä–µ–∞–ª—å–Ω–æ–º –∫–æ–¥–µ –∑–¥–µ—Å—å –±—ã–ª –±—ã –≤—ã–∑–æ–≤ LLM
        # prompt = f"Context: {context}\n\nQuestion: {question}\n\nAnswer:"
        # response = llm.predict(prompt)

        # –ü—Ä–æ—Å—Ç–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
        if context:
            answer = f"Based on the provided context, I can answer your question about '{question}'. The relevant information suggests that this topic involves multiple aspects that need to be considered."
        else:
            answer = f"I don't have specific information in my knowledge base to answer '{question}' accurately."

        return answer

# –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è RAG —Å–∏—Å—Ç–µ–º—ã
def demo_rag_system():
    """–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è RAG —Å–∏—Å—Ç–µ–º—ã"""
    print("\n=== PRODUCTION RAG –°–ò–°–¢–ï–ú–ê ===")

    # –ü—Ä–∏–º–µ—Ä–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã
    sample_docs = [
        "–ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç (–ò–ò) ‚Äî —ç—Ç–æ –æ–±–ª–∞—Å—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∏, –∫–æ—Ç–æ—Ä–∞—è –∑–∞–Ω–∏–º–∞–µ—Ç—Å—è —Å–æ–∑–¥–∞–Ω–∏–µ–º –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã—Ö –º–∞—à–∏–Ω, —Å–ø–æ—Å–æ–±–Ω—ã—Ö —Ä–∞–±–æ—Ç–∞—Ç—å –∏ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∫ –ª—é–¥–∏.",
        "–ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ —è–≤–ª—è–µ—Ç—Å—è –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ–º –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞, –∫–æ—Ç–æ—Ä–æ–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Å–∏—Å—Ç–µ–º–∞–º —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É—á–∏—Ç—å—Å—è –∏ —É–ª—É—á—à–∞—Ç—å—Å—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–ø—ã—Ç–∞.",
        "–ì–ª—É–±–æ–∫–æ–µ –æ–±—É—á–µ–Ω–∏–µ - —ç—Ç–æ –ø–æ–¥—Ä–∞–∑–¥–µ–ª –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã—Ö –Ω–µ–π—Ä–æ–Ω–Ω—ã—Ö —Å–µ—Ç—è—Ö —Å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º –æ–±—É—á–µ–Ω–∏—è.",
        "–ù–µ–π—Ä–æ–Ω–Ω—ã–µ —Å–µ—Ç–∏ –≤–¥–æ—Ö–Ω–æ–≤–ª–µ–Ω—ã –±–∏–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–º–∏ –Ω–µ–π—Ä–æ–Ω–Ω—ã–º–∏ —Å–µ—Ç—è–º–∏ –º–æ–∑–≥–∞ –∂–∏–≤–æ—Ç–Ω—ã—Ö –∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è —Ä–µ—à–µ–Ω–∏—è —à–∏—Ä–æ–∫–æ–≥–æ –∫—Ä—É–≥–∞ –∑–∞–¥–∞—á."
    ]

    # –°–æ–∑–¥–∞–Ω–∏–µ RAG —Å–∏—Å—Ç–µ–º—ã
    rag_agent = ProductionRAGAgent(documents=sample_docs)

    # –¢–µ—Å—Ç–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã
    test_questions = [
        "–ß—Ç–æ —Ç–∞–∫–æ–µ –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç?",
        "–ö–∞–∫ —Å–≤—è–∑–∞–Ω–æ –º–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ —Å –ò–ò?",
        "–û–±—ä—è—Å–Ω–∏ –≥–ª—É–±–æ–∫–æ–µ –æ–±—É—á–µ–Ω–∏–µ",
        "–†–∞—Å—Å–∫–∞–∂–∏ –æ –Ω–µ–π—Ä–æ–Ω–Ω—ã—Ö —Å–µ—Ç—è—Ö"
    ]

    for question in test_questions:
        print(f"\n–í–æ–ø—Ä–æ—Å: {question}")
        result = rag_agent.query(question)

        print(f"–¢–∏–ø –∑–∞–ø—Ä–æ—Å–∞: {result['query_type']}")
        print(f"–ù–∞–π–¥–µ–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤: {result['relevant_documents']}")
        print(f"–û—Ç–≤–µ—Ç: {result['answer']}")
        print(f"–ò—Å—Ç–æ—á–Ω–∏–∫–∏: {result['sources']}")

# –ó–∞–ø—É—Å–∫ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ RAG
demo_rag_system()

# =============================================================================
# –†–ê–ó–î–ï–õ 11: –ú–û–ù–ò–¢–û–†–ò–ù–ì –ò DEPLOYMENT
# =============================================================================

class AgentMonitoringSystem:
    """
    –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –¥–ª—è production –∞–≥–µ–Ω—Ç–æ–≤

    –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç:
    - –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
    - –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤
    - –ö–∞—á–µ—Å—Ç–≤–æ –æ—Ç–≤–µ—Ç–æ–≤
    - –û—à–∏–±–∫–∏ –∏ –∏—Å–∫–ª—é—á–µ–Ω–∏—è
    """

    def __init__(self):
        self.metrics = {
            "total_queries": 0,
            "successful_queries": 0,
            "failed_queries": 0,
            "average_response_time": 0.0,
            "error_types": {},
            "query_types": {},
            "response_quality_scores": []
        }

        self.logs = []

        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –≤ —Ñ–∞–π–ª
        self._setup_logging()

    def _setup_logging(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∏—Å—Ç–µ–º—ã –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è"""
        log_formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )

        file_handler = logging.FileHandler('agent_monitoring.log')
        file_handler.setFormatter(log_formatter)

        console_handler = logging.StreamHandler()
        console_handler.setFormatter(log_formatter)

        self.logger = logging.getLogger('AgentMonitoring')
        self.logger.setLevel(logging.INFO)
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)

    def log_query(self, 
                  query: str, 
                  response: str, 
                  response_time: float, 
                  success: bool,
                  error: str = None,
                  query_type: str = "general"):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞"""

        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫
        self.metrics["total_queries"] += 1

        if success:
            self.metrics["successful_queries"] += 1
        else:
            self.metrics["failed_queries"] += 1
            if error:
                self.metrics["error_types"][error] = self.metrics["error_types"].get(error, 0) + 1

        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–≤–µ—Ç–∞
        total_time = self.metrics["average_response_time"] * (self.metrics["total_queries"] - 1)
        self.metrics["average_response_time"] = (total_time + response_time) / self.metrics["total_queries"]

        # –ü–æ–¥—Å—á–µ—Ç —Ç–∏–ø–æ–≤ –∑–∞–ø—Ä–æ—Å–æ–≤
        self.metrics["query_types"][query_type] = self.metrics["query_types"].get(query_type, 0) + 1

        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "query": query[:100] + "..." if len(query) > 100 else query,
            "response_length": len(response),
            "response_time": response_time,
            "success": success,
            "error": error,
            "query_type": query_type
        }

        self.logs.append(log_entry)

        if success:
            self.logger.info(f"Query processed successfully in {response_time:.2f}s")
        else:
            self.logger.error(f"Query failed: {error}")

    def get_metrics_summary(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–∫–∏ –º–µ—Ç—Ä–∏–∫"""
        success_rate = (self.metrics["successful_queries"] / self.metrics["total_queries"] * 100) if self.metrics["total_queries"] > 0 else 0

        return {
            "total_queries": self.metrics["total_queries"],
            "success_rate": f"{success_rate:.2f}%",
            "average_response_time": f"{self.metrics['average_response_time']:.2f}s",
            "most_common_errors": dict(sorted(self.metrics["error_types"].items(), key=lambda x: x[1], reverse=True)[:3]),
            "query_type_distribution": self.metrics["query_types"],
            "uptime": "Available in production deployment"
        }

    def generate_report(self) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á–µ—Ç–∞ –æ —Ä–∞–±–æ—Ç–µ –∞–≥–µ–Ω—Ç–∞"""
        metrics = self.get_metrics_summary()

        report = f"""
=== AGENT MONITORING REPORT ===
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Performance Metrics:
- Total Queries: {metrics['total_queries']}
- Success Rate: {metrics['success_rate']}
- Average Response Time: {metrics['average_response_time']}

Query Types:
"""
        for query_type, count in metrics['query_type_distribution'].items():
            report += f"- {query_type}: {count} queries\n"

        report += f"""
Most Common Errors:
"""
        for error, count in metrics['most_common_errors'].items():
            report += f"- {error}: {count} occurrences\n"

        report += f"""
Recent Activity:
"""
        for log_entry in self.logs[-5:]:  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 5 –∑–∞–ø–∏—Å–µ–π
            status = "‚úÖ" if log_entry['success'] else "‚ùå"
            report += f"{status} {log_entry['timestamp']}: {log_entry['query']} ({log_entry['response_time']:.2f}s)\n"

        return report

# –ü—Ä–∏–º–µ—Ä –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å –∞–≥–µ–Ω—Ç–æ–º
class MonitoredAgent:
    """–ê–≥–µ–Ω—Ç —Å –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º"""

    def __init__(self):
        self.monitoring = AgentMonitoringSystem()
        self.tools = ["calculator", "search", "datetime"]

    def process_query(self, query: str) -> str:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ —Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º"""
        start_time = datetime.now()

        try:
            # –ò–º–∏—Ç–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞
            import time
            time.sleep(0.1)  # –ò–º–∏—Ç–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏

            if "error" in query.lower():
                raise Exception("Simulated error for testing")

            response = f"Processed query: {query} (length: {len(query)} chars)"

            # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∑–∞–ø—Ä–æ—Å–∞
            if "calculate" in query.lower():
                query_type = "calculation"
            elif "search" in query.lower():
                query_type = "search"
            else:
                query_type = "general"

            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
            response_time = (datetime.now() - start_time).total_seconds()
            self.monitoring.log_query(
                query=query,
                response=response,
                response_time=response_time,
                success=True,
                query_type=query_type
            )

            return response

        except Exception as e:
            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–∫–∏
            response_time = (datetime.now() - start_time).total_seconds()
            self.monitoring.log_query(
                query=query,
                response="",
                response_time=response_time,
                success=False,
                error=str(e)
            )

            return f"Error processing query: {str(e)}"

    def get_health_status(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–¥–æ—Ä–æ–≤—å—è –∞–≥–µ–Ω—Ç–∞"""
        metrics = self.monitoring.get_metrics_summary()

        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–¥–æ—Ä–æ–≤—å—è
        success_rate = float(metrics['success_rate'].replace('%', ''))
        avg_time = float(metrics['average_response_time'].replace('s', ''))

        if success_rate > 95 and avg_time < 2.0:
            health_status = "HEALTHY"
        elif success_rate > 80 and avg_time < 5.0:
            health_status = "WARNING"
        else:
            health_status = "CRITICAL"

        return {
            "status": health_status,
            "metrics": metrics,
            "timestamp": datetime.now().isoformat()
        }

# –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
def demo_monitoring():
    """–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
    print("\n=== –°–ò–°–¢–ï–ú–ê –ú–û–ù–ò–¢–û–†–ò–ù–ì–ê –ê–ì–ï–ù–¢–û–í ===")

    agent = MonitoredAgent()

    # –¢–µ—Å—Ç–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã
    test_queries = [
        "Calculate 15 + 25",
        "Search for information about AI",
        "What is the current time?",
        "This query should cause an error",  # –í—ã–∑–æ–≤–µ—Ç –æ—à–∏–±–∫—É
        "Another successful query"
    ]

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤
    for query in test_queries:
        print(f"\nProcessing: {query}")
        response = agent.process_query(query)
        print(f"Response: {response}")

    # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–¥–æ—Ä–æ–≤—å—è
    health = agent.get_health_status()
    print(f"\n=== HEALTH STATUS ===")
    print(f"Status: {health['status']}")
    print(f"Success Rate: {health['metrics']['success_rate']}")
    print(f"Avg Response Time: {health['metrics']['average_response_time']}")

    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á–µ—Ç–∞
    report = agent.monitoring.generate_report()
    print(f"\n=== MONITORING REPORT ===")
    print(report)

# –ó–∞–ø—É—Å–∫ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
demo_monitoring()

print("\n‚úÖ Production-ready –ø—Ä–∏–º–µ—Ä—ã —Å–æ–∑–¥–∞–Ω—ã –∏ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã!")
